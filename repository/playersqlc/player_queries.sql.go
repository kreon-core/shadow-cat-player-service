// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: player_queries.sql

package playersqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNewPlayer = `-- name: CreateNewPlayer :one
INSERT INTO
    player (
        id, coins, gems,
        current_energy, max_energy,
        best_map
    )
VALUES
    ($1, $2, $3, $4, $5, $6)
RETURNING
    id, level, exp, coins, gems,
    best_map,
    current_skin, equipped_props
`

type CreateNewPlayerParams struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	Coins         int32       `db:"coins" json:"coins"`
	Gems          int32       `db:"gems" json:"gems"`
	CurrentEnergy int32       `db:"current_energy" json:"current_energy"`
	MaxEnergy     int32       `db:"max_energy" json:"max_energy"`
	BestMap       []byte      `db:"best_map" json:"best_map"`
}

type CreateNewPlayerRow struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	Level         int32       `db:"level" json:"level"`
	Exp           int32       `db:"exp" json:"exp"`
	Coins         int32       `db:"coins" json:"coins"`
	Gems          int32       `db:"gems" json:"gems"`
	BestMap       []byte      `db:"best_map" json:"best_map"`
	CurrentSkin   int32       `db:"current_skin" json:"current_skin"`
	EquippedProps []byte      `db:"equipped_props" json:"equipped_props"`
}

func (q *Queries) CreateNewPlayer(ctx context.Context, arg CreateNewPlayerParams) (CreateNewPlayerRow, error) {
	row := q.db.QueryRow(ctx, createNewPlayer,
		arg.ID,
		arg.Coins,
		arg.Gems,
		arg.CurrentEnergy,
		arg.MaxEnergy,
		arg.BestMap,
	)
	var i CreateNewPlayerRow
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Exp,
		&i.Coins,
		&i.Gems,
		&i.BestMap,
		&i.CurrentSkin,
		&i.EquippedProps,
	)
	return i, err
}

const getPlayerByID = `-- name: GetPlayerByID :one
SELECT
    id, level, exp, coins, gems,
    best_map,
    current_skin, equipped_props
FROM
    player
WHERE
    id = $1
`

type GetPlayerByIDRow struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	Level         int32       `db:"level" json:"level"`
	Exp           int32       `db:"exp" json:"exp"`
	Coins         int32       `db:"coins" json:"coins"`
	Gems          int32       `db:"gems" json:"gems"`
	BestMap       []byte      `db:"best_map" json:"best_map"`
	CurrentSkin   int32       `db:"current_skin" json:"current_skin"`
	EquippedProps []byte      `db:"equipped_props" json:"equipped_props"`
}

func (q *Queries) GetPlayerByID(ctx context.Context, id pgtype.UUID) (GetPlayerByIDRow, error) {
	row := q.db.QueryRow(ctx, getPlayerByID, id)
	var i GetPlayerByIDRow
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Exp,
		&i.Coins,
		&i.Gems,
		&i.BestMap,
		&i.CurrentSkin,
		&i.EquippedProps,
	)
	return i, err
}

const getPlayerEnergyByID = `-- name: GetPlayerEnergyByID :one
SELECT
    current_energy,
    max_energy,
    next_energy_at
FROM
    player
WHERE
    id = $1
`

type GetPlayerEnergyByIDRow struct {
	CurrentEnergy int32              `db:"current_energy" json:"current_energy"`
	MaxEnergy     int32              `db:"max_energy" json:"max_energy"`
	NextEnergyAt  pgtype.Timestamptz `db:"next_energy_at" json:"next_energy_at"`
}

func (q *Queries) GetPlayerEnergyByID(ctx context.Context, id pgtype.UUID) (GetPlayerEnergyByIDRow, error) {
	row := q.db.QueryRow(ctx, getPlayerEnergyByID, id)
	var i GetPlayerEnergyByIDRow
	err := row.Scan(&i.CurrentEnergy, &i.MaxEnergy, &i.NextEnergyAt)
	return i, err
}

const updatePlayer = `-- name: UpdatePlayer :one
UPDATE player
SET
    level = $2,
    exp = $3,
    coins = $4,
    gems = $5,
    best_map = $6,
    current_skin = $7,
    equipped_props = $8,
    updated_at = NOW()
WHERE
    id = $1
RETURNING
    id, level, exp, coins, gems,
    best_map,
    current_skin, equipped_props
`

type UpdatePlayerParams struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	Level         int32       `db:"level" json:"level"`
	Exp           int32       `db:"exp" json:"exp"`
	Coins         int32       `db:"coins" json:"coins"`
	Gems          int32       `db:"gems" json:"gems"`
	BestMap       []byte      `db:"best_map" json:"best_map"`
	CurrentSkin   int32       `db:"current_skin" json:"current_skin"`
	EquippedProps []byte      `db:"equipped_props" json:"equipped_props"`
}

type UpdatePlayerRow struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	Level         int32       `db:"level" json:"level"`
	Exp           int32       `db:"exp" json:"exp"`
	Coins         int32       `db:"coins" json:"coins"`
	Gems          int32       `db:"gems" json:"gems"`
	BestMap       []byte      `db:"best_map" json:"best_map"`
	CurrentSkin   int32       `db:"current_skin" json:"current_skin"`
	EquippedProps []byte      `db:"equipped_props" json:"equipped_props"`
}

func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) (UpdatePlayerRow, error) {
	row := q.db.QueryRow(ctx, updatePlayer,
		arg.ID,
		arg.Level,
		arg.Exp,
		arg.Coins,
		arg.Gems,
		arg.BestMap,
		arg.CurrentSkin,
		arg.EquippedProps,
	)
	var i UpdatePlayerRow
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Exp,
		&i.Coins,
		&i.Gems,
		&i.BestMap,
		&i.CurrentSkin,
		&i.EquippedProps,
	)
	return i, err
}

const updatePlayerEnergy = `-- name: UpdatePlayerEnergy :one
UPDATE player
SET
    current_energy = $2,
    next_energy_at = $3,
    updated_at = NOW()
WHERE
    id = $1
RETURNING
    current_energy,
    max_energy,
    next_energy_at
`

type UpdatePlayerEnergyParams struct {
	ID            pgtype.UUID        `db:"id" json:"id"`
	CurrentEnergy int32              `db:"current_energy" json:"current_energy"`
	NextEnergyAt  pgtype.Timestamptz `db:"next_energy_at" json:"next_energy_at"`
}

type UpdatePlayerEnergyRow struct {
	CurrentEnergy int32              `db:"current_energy" json:"current_energy"`
	MaxEnergy     int32              `db:"max_energy" json:"max_energy"`
	NextEnergyAt  pgtype.Timestamptz `db:"next_energy_at" json:"next_energy_at"`
}

func (q *Queries) UpdatePlayerEnergy(ctx context.Context, arg UpdatePlayerEnergyParams) (UpdatePlayerEnergyRow, error) {
	row := q.db.QueryRow(ctx, updatePlayerEnergy, arg.ID, arg.CurrentEnergy, arg.NextEnergyAt)
	var i UpdatePlayerEnergyRow
	err := row.Scan(&i.CurrentEnergy, &i.MaxEnergy, &i.NextEnergyAt)
	return i, err
}
