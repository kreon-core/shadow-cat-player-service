// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory_queries.sql

package playersqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getInventoryByPlayerID = `-- name: GetInventoryByPlayerID :one
SELECT
    array_agg(skin.id) AS owned_skins,
    array_agg(
        json_build_object(
            'prop_id',
            prop.id,
            'config_prop_id',
            prop.config_prop_id,
            'level',
            prop.level,
            'quantity',
            prop.quantity
        )
    ) AS owned_props
FROM
    player
    INNER JOIN skin ON player.id = skin.player_id
    INNER JOIN prop ON player.id = prop.player_id
WHERE
    player.id = $1
GROUP BY
    player.id
`

type GetInventoryByPlayerIDRow struct {
	OwnedSkins interface{} `db:"owned_skins" json:"owned_skins"`
	OwnedProps interface{} `db:"owned_props" json:"owned_props"`
}

func (q *Queries) GetInventoryByPlayerID(ctx context.Context, id pgtype.UUID) (GetInventoryByPlayerIDRow, error) {
	row := q.db.QueryRow(ctx, getInventoryByPlayerID, id)
	var i GetInventoryByPlayerIDRow
	err := row.Scan(&i.OwnedSkins, &i.OwnedProps)
	return i, err
}

const insertOwnedSkins = `-- name: InsertOwnedSkins :many
INSERT INTO
    skin (player_id, config_skin_id)
SELECT
    player_id, config_skin_id
FROM jsonb_to_recordset($1::jsonb) AS p(
    player_id uuid,
    config_skin_id int
)
ON CONFLICT (player_id, config_skin_id) DO NOTHING
RETURNING skin.id
`

func (q *Queries) InsertOwnedSkins(ctx context.Context, dollar_1 []byte) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, insertOwnedSkins, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeOwnedSkins = `-- name: RemoveOwnedSkins :many
DELETE FROM
    skin
WHERE
    player_id = $1
    AND config_skin_id = ANY($2::int[])
RETURNING id
`

type RemoveOwnedSkinsParams struct {
	PlayerID pgtype.UUID `db:"player_id" json:"player_id"`
	Column2  []int32     `db:"column_2" json:"column_2"`
}

func (q *Queries) RemoveOwnedSkins(ctx context.Context, arg RemoveOwnedSkinsParams) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, removeOwnedSkins, arg.PlayerID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeQuantityProp = `-- name: RemoveQuantityProp :one
UPDATE prop
SET
    quantity = quantity - $2,
    updated_at = NOW()
WHERE
    id = $1
    AND quantity >= $2
RETURNING id, quantity
`

type RemoveQuantityPropParams struct {
	ID       pgtype.UUID `db:"id" json:"id"`
	Quantity int32       `db:"quantity" json:"quantity"`
}

type RemoveQuantityPropRow struct {
	ID       pgtype.UUID `db:"id" json:"id"`
	Quantity int32       `db:"quantity" json:"quantity"`
}

func (q *Queries) RemoveQuantityProp(ctx context.Context, arg RemoveQuantityPropParams) (RemoveQuantityPropRow, error) {
	row := q.db.QueryRow(ctx, removeQuantityProp, arg.ID, arg.Quantity)
	var i RemoveQuantityPropRow
	err := row.Scan(&i.ID, &i.Quantity)
	return i, err
}

const upsertOwnedProps = `-- name: UpsertOwnedProps :many
INSERT INTO
    prop (player_id, config_prop_id, level, quantity)
SELECT
    player_id, config_prop_id, level, quantity
FROM jsonb_to_recordset($1::jsonb) AS p(
    player_id uuid,
    config_prop_id int,
    level int,
    quantity int
)
ON CONFLICT (player_id, config_prop_id, level) DO UPDATE
SET
    quantity = prop.quantity + EXCLUDED.quantity
RETURNING prop.id
`

func (q *Queries) UpsertOwnedProps(ctx context.Context, dollar_1 []byte) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, upsertOwnedProps, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
