// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tower_queries.sql

package playersqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTowerTicketsToPlayer = `-- name: AddTowerTicketsToPlayer :one
INSERT INTO
    tower (player_id, tower_id, ticket)
VALUES
    ($1, $2, $3)
ON CONFLICT (tower_id, player_id) DO UPDATE
SET
    ticket = tower.ticket + EXCLUDED.ticket,
    updated_at = NOW()
RETURNING
    tower_id,
    ticket,
    highest_floor
`

type AddTowerTicketsToPlayerParams struct {
	PlayerID pgtype.UUID `db:"player_id" json:"player_id"`
	TowerID  int32       `db:"tower_id" json:"tower_id"`
	Ticket   int32       `db:"ticket" json:"ticket"`
}

type AddTowerTicketsToPlayerRow struct {
	TowerID      int32 `db:"tower_id" json:"tower_id"`
	Ticket       int32 `db:"ticket" json:"ticket"`
	HighestFloor int32 `db:"highest_floor" json:"highest_floor"`
}

func (q *Queries) AddTowerTicketsToPlayer(ctx context.Context, arg AddTowerTicketsToPlayerParams) (AddTowerTicketsToPlayerRow, error) {
	row := q.db.QueryRow(ctx, addTowerTicketsToPlayer, arg.PlayerID, arg.TowerID, arg.Ticket)
	var i AddTowerTicketsToPlayerRow
	err := row.Scan(&i.TowerID, &i.Ticket, &i.HighestFloor)
	return i, err
}

const consumeTowerTicketsFromPlayer = `-- name: ConsumeTowerTicketsFromPlayer :one
UPDATE tower
SET
    ticket = ticket - $3,
    updated_at = NOW()
WHERE
    player_id = $1
    AND tower_id = $2
    AND ticket >= $3
RETURNING
    tower_id,
    ticket,
    highest_floor
`

type ConsumeTowerTicketsFromPlayerParams struct {
	PlayerID pgtype.UUID `db:"player_id" json:"player_id"`
	TowerID  int32       `db:"tower_id" json:"tower_id"`
	Ticket   int32       `db:"ticket" json:"ticket"`
}

type ConsumeTowerTicketsFromPlayerRow struct {
	TowerID      int32 `db:"tower_id" json:"tower_id"`
	Ticket       int32 `db:"ticket" json:"ticket"`
	HighestFloor int32 `db:"highest_floor" json:"highest_floor"`
}

func (q *Queries) ConsumeTowerTicketsFromPlayer(ctx context.Context, arg ConsumeTowerTicketsFromPlayerParams) (ConsumeTowerTicketsFromPlayerRow, error) {
	row := q.db.QueryRow(ctx, consumeTowerTicketsFromPlayer, arg.PlayerID, arg.TowerID, arg.Ticket)
	var i ConsumeTowerTicketsFromPlayerRow
	err := row.Scan(&i.TowerID, &i.Ticket, &i.HighestFloor)
	return i, err
}

const getTowerProgressByPlayerID = `-- name: GetTowerProgressByPlayerID :many
SELECT
    tower_id,
    ticket,
    highest_floor
FROM
    tower
WHERE
    player_id = $1
`

type GetTowerProgressByPlayerIDRow struct {
	TowerID      int32 `db:"tower_id" json:"tower_id"`
	Ticket       int32 `db:"ticket" json:"ticket"`
	HighestFloor int32 `db:"highest_floor" json:"highest_floor"`
}

func (q *Queries) GetTowerProgressByPlayerID(ctx context.Context, playerID pgtype.UUID) ([]GetTowerProgressByPlayerIDRow, error) {
	rows, err := q.db.Query(ctx, getTowerProgressByPlayerID, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTowerProgressByPlayerIDRow{}
	for rows.Next() {
		var i GetTowerProgressByPlayerIDRow
		if err := rows.Scan(&i.TowerID, &i.Ticket, &i.HighestFloor); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTowerProgressByPlayerIDAndTowerID = `-- name: GetTowerProgressByPlayerIDAndTowerID :one
SELECT
    tower_id,
    ticket,
    highest_floor
FROM
    tower
WHERE
    player_id = $1
    AND tower_id = $2
`

type GetTowerProgressByPlayerIDAndTowerIDParams struct {
	PlayerID pgtype.UUID `db:"player_id" json:"player_id"`
	TowerID  int32       `db:"tower_id" json:"tower_id"`
}

type GetTowerProgressByPlayerIDAndTowerIDRow struct {
	TowerID      int32 `db:"tower_id" json:"tower_id"`
	Ticket       int32 `db:"ticket" json:"ticket"`
	HighestFloor int32 `db:"highest_floor" json:"highest_floor"`
}

func (q *Queries) GetTowerProgressByPlayerIDAndTowerID(ctx context.Context, arg GetTowerProgressByPlayerIDAndTowerIDParams) (GetTowerProgressByPlayerIDAndTowerIDRow, error) {
	row := q.db.QueryRow(ctx, getTowerProgressByPlayerIDAndTowerID, arg.PlayerID, arg.TowerID)
	var i GetTowerProgressByPlayerIDAndTowerIDRow
	err := row.Scan(&i.TowerID, &i.Ticket, &i.HighestFloor)
	return i, err
}

const upsertTowerProgressOnPlayer = `-- name: UpsertTowerProgressOnPlayer :exec
INSERT INTO
    tower (player_id, tower_id, highest_floor)
VALUES
    ($1, $2, $3)
ON CONFLICT (tower_id, player_id) DO UPDATE
SET
    highest_floor = GREATEST(tower.highest_floor, EXCLUDED.highest_floor),
    updated_at = NOW()
`

type UpsertTowerProgressOnPlayerParams struct {
	PlayerID     pgtype.UUID `db:"player_id" json:"player_id"`
	TowerID      int32       `db:"tower_id" json:"tower_id"`
	HighestFloor int32       `db:"highest_floor" json:"highest_floor"`
}

func (q *Queries) UpsertTowerProgressOnPlayer(ctx context.Context, arg UpsertTowerProgressOnPlayerParams) error {
	_, err := q.db.Exec(ctx, upsertTowerProgressOnPlayer, arg.PlayerID, arg.TowerID, arg.HighestFloor)
	return err
}
