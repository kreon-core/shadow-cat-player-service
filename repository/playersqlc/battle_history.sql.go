// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: battle_history.sql

package playersqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const completeBattleHistory = `-- name: CompleteBattleHistory :one
UPDATE battle_history
SET completed_at = NOW(),
    time_survived = $2,
    monster_kills = $3,
    total_damage_dealt = $4,
    updated_at = NOW()
WHERE id = $1
    AND completed_at IS NULL
RETURNING id, player_id, game_mode, tower_id, floor, map_id, completed_at, exited_at, time_survived, monster_kills, total_damage_dealt, created_at, updated_at
`

type CompleteBattleHistoryParams struct {
	ID               pgtype.UUID `db:"id" json:"id"`
	TimeSurvived     int32       `db:"time_survived" json:"time_survived"`
	MonsterKills     int32       `db:"monster_kills" json:"monster_kills"`
	TotalDamageDealt int32       `db:"total_damage_dealt" json:"total_damage_dealt"`
}

func (q *Queries) CompleteBattleHistory(ctx context.Context, arg CompleteBattleHistoryParams) (BattleHistory, error) {
	row := q.db.QueryRow(ctx, completeBattleHistory,
		arg.ID,
		arg.TimeSurvived,
		arg.MonsterKills,
		arg.TotalDamageDealt,
	)
	var i BattleHistory
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.GameMode,
		&i.TowerID,
		&i.Floor,
		&i.MapID,
		&i.CompletedAt,
		&i.ExitedAt,
		&i.TimeSurvived,
		&i.MonsterKills,
		&i.TotalDamageDealt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const exitBattleHistory = `-- name: ExitBattleHistory :exec
UPDATE battle_history
SET exited_at = NOW(),
    updated_at = NOW()
WHERE id = $1
    AND completed_at IS NULL
`

func (q *Queries) ExitBattleHistory(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, exitBattleHistory, id)
	return err
}

const getBattleHistoryByID = `-- name: GetBattleHistoryByID :one
SELECT id, player_id, game_mode, tower_id, floor, map_id, completed_at, exited_at, time_survived, monster_kills, total_damage_dealt, created_at, updated_at
FROM battle_history
WHERE id = $1
`

func (q *Queries) GetBattleHistoryByID(ctx context.Context, id pgtype.UUID) (BattleHistory, error) {
	row := q.db.QueryRow(ctx, getBattleHistoryByID, id)
	var i BattleHistory
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.GameMode,
		&i.TowerID,
		&i.Floor,
		&i.MapID,
		&i.CompletedAt,
		&i.ExitedAt,
		&i.TimeSurvived,
		&i.MonsterKills,
		&i.TotalDamageDealt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertBattleHistory = `-- name: UpsertBattleHistory :one
INSERT INTO battle_history (player_id, game_mode, tower_id, floor, map_id, time_survived)
VALUES ($1, $2, $3, $4, $5, 0)
ON CONFLICT (player_id)
    WHERE completed_at IS NULL
DO UPDATE SET
    updated_at = NOW()
RETURNING id, player_id, game_mode, tower_id, floor, map_id, completed_at, exited_at, time_survived, monster_kills, total_damage_dealt, created_at, updated_at
`

type UpsertBattleHistoryParams struct {
	PlayerID pgtype.UUID `db:"player_id" json:"player_id"`
	GameMode int32       `db:"game_mode" json:"game_mode"`
	TowerID  pgtype.Int4 `db:"tower_id" json:"tower_id"`
	Floor    pgtype.Int4 `db:"floor" json:"floor"`
	MapID    pgtype.Int4 `db:"map_id" json:"map_id"`
}

func (q *Queries) UpsertBattleHistory(ctx context.Context, arg UpsertBattleHistoryParams) (BattleHistory, error) {
	row := q.db.QueryRow(ctx, upsertBattleHistory,
		arg.PlayerID,
		arg.GameMode,
		arg.TowerID,
		arg.Floor,
		arg.MapID,
	)
	var i BattleHistory
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.GameMode,
		&i.TowerID,
		&i.Floor,
		&i.MapID,
		&i.CompletedAt,
		&i.ExitedAt,
		&i.TimeSurvived,
		&i.MonsterKills,
		&i.TotalDamageDealt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
